# 3

## Оставшееся со 2го семинара

Напомню: UB = Undefined Behaviour. В других контекстах это сокращение значения не меняет. В ситуации с UB компилятор может лишь развести ручками, потому что это настолько широкий класс случаев, что никаких
разумных проверок для него придумать нельзя, да и даже отследить UB крайне трудно.

Поэтому, помимо UB есть другие классы ситуаций, когда от компилятора могут требовать _выдавать диагностику (предупреждения, ошибки)_.

### Unspecified Behaviour

В UB стандарт языка не даёт вообще никаких гарантий. Это значит, что программа может внезапно завершиться, или, например, ненарочно сломать вашу операционную систему. Однако есть ситуации, когда поведение
программы в каком-то смысле _случайно_, но у нас есть _понимание_, что в любой ситуации программа просто корректно отработает и тяжелых последствий не будет. Такие ситуации выносятся под категорию _unspecified
behaviour_.

**Важно:** компилятор _не обязан_ в своей спецификации объяснять, как именно разрешается тот или иной случай unspecified behaviour

**Пример:** порядок вычисления выражения определяется компилятором, но от этого плохо никому не становится (не должно, по крайней мере)
```c++
#include <iostream>

int f() {
   std::cout << "Hi, I'm f!" << std::endl;
   return 1;
}

int g() {
   std::cout << "Hi, I'm g!" << std::endl;
   return 2;
}

int h() {
   std::cout << "Hi, I'm h!" << std::endl;
   return 3;
}

int main() {
   f() + g() * h();  // value is well-defined, but the output of the program?... Any order is possible, and it's ok!
}
```

**Пример:**
```c++
#include <iostream>

void f(int x, int y) {
   std::cout << x << ' ' << y << std::endl;
}

int main() {
   int a = 1;
   f(++a, ++a);  // output? Again, unspecified behaviour
}
```

### Implementation-Defined Behaviour

Если спросить человека: "Какой размер у `int`?", то ответ 4 будет ошибкой. После продолжительного опыта использования языка должно быть известно, что такая деталь зависит от ОС и железа. Именно такие ситуации
относятся к implementation-defined behaviour, но без каких-либо дополнений это получится... просто unspecified behaviour?

**Важно:** компилятор _обязан_ в своей спецификации объяснять, как именно разрешается тот или иной случай implementation-defined behaviour

**Пример:** любой вызов `sizeof`

**Пример:** как известно, дробные числа (да и вообще все доступные в компьютере) сегодня записаны через двоичную систему чисел. Это приводит к тому, что часть из них невозможно точно представить. Так, литерал
`0.1f` компилятору придётся куда-то округлить. А куда, собственно? Это implementation-defined behaviour!

**Замечание:** к слову, тот факт что 1 байт = 8 бит - это тоже implementation-defined behaviour. Сама величина "байт" действительно стандартизовано, но бывают разные машины, где, например, [1 байт = 36 бит](https://en.wikipedia.org/wiki/PDP-10)

### Ill-Formed, No Diagnostics Required (IFNDR)

Язык C++ настолько богат, что существует возможность объявить функцию в одном файле, а определить уже в другом. Из-за этого компиляция файла без определения функции является вполне корректной вещью:
```c++
void f();

int main() {
   f();
}
```

### Errorneous behaviour (C++26)

Класс UB не требует (да и не может) никакой диагностики. Очевидно, для удобства жизни программистов было бы хорошо, чтобы таких ситуаций в языке было как можно меньше. Поэтому, из UB выделили дополнительную
часть под названием errorneous behaviour, которая включает в себя небольшую группу простых диагностируемых ошибок.

**Пример:**
```c++
#include <iostream>

int main() {
   int x;
   int y = x;  // errorneous behaviour, x is not initialized
   std::cout << y;
}
```

## Отслеживание ошибок

Язык C++ - сложный. Это уже привело к тому, что компилятор сообщает нам не о всех проблемах, которые могут быть в нашей программе (чтобы мы не утонули в их разборе). Однако, компилятор можно попросить явно
говорить о всех проблемах. Для этого есть флаг `-Wall`.

**Пример:** `clang++ -Wall main.cpp`

Также, можно попросить компилятор считать все предупреждения ошибками через `-Werror`.

Так как существуют разные компиляторы, то они могут делать некоторые вещи по-разному, а порой и добавлять свои особые детали в язык. Например, GNU GCC предоставляет структуру данных `pbds`, которую не найти в
остальных компиляторах. Для проверки, что ваш код может работать под любым компилятором (т.е. он _кросс-платформенный_), существует специальный флажок `-Wpedantic`, при включении которого компилятор расскажет
обо всех необычных деталях в вашей программе.

## Массивы

### На стеке

#### Самая база

Из C в язык C++ перекочевал такой концепт как _массивы_. Это тип, который позволяет работать с несколькими объектами одного и того же типа, _непрерывно_ лежащими в памяти.

**Пример:**
```c++
#include <iostream>

int main() {
   int a[5] = {0, 1, 2, 3, 4};
   
   for (ssize_t i = 0; i < 5; ++i) {
      std::cout << a[i] << ' ';  // accessing i-th element via operator[]
   }
   std::cout << std::endl;
}
```

Тип переменной `a` в примере выше - `int[5]`, специальный тип для _массива из 5 элементов типа `int`_.

Также возможно указывать не все элементы массива при его инициализации:
 - `int a[5] = {0, 1, 2};` - последние 2 элемента будут проинициализированы по умолчанию (для `int` это ноль)
 - `int a[5] = {};` - все элементы будут проинициализированы по умолчанию
 - `int a[5];` - никакой элемент массива не будет проинициализирован, в них записан мусор.

**Замечание:** массивы нельзя переприсваивать
```c++
int main() {
   int a[5] = {};
   int b[5] = a;  // CE
}
```

**Замечание:** если вызвать `sizeof` от объекта массива, то получится размер всего _массива в байтах_, то есть фактически `n * sizeof(T)` (где `n` - размер массива и `T` - тип элемента этого массива)

**Замечание:** порой бывает лень самостоятельно считать размер массива. Это нормально, и поэтому придумали вариант, когда размер при объявлении не пишется, но тогда компилятор посчитает его сам, при помощи
сразу идущего определения:
```c++
int main() {
   int a[] = {0, 1, 2, 3};
   // Type of a is still int[4]
}
```

#### Array-to-pointer conversion

Так уж оказывается, что тип массива запредельно похож на тип указателя. Действительно, мы умеем двигать указатель на 1, что соответствует следующему ближайшему объекту в памяти того же типа. Поэтому
существует даже _неявное приведение типа массива к соответствующему типу указателя_. В результате, легально писать такое:
```c++
#include <iostream>

int main() {
    int a[5] = {};
    std::cout << &a << std::endl;
    std::cout << *(a + 3) << std::endl;  // a is implicitly converted to int*
}
```

Более того, эти типы настолько похожи, что на самом деле обращение к элементу `a[i]` в самом прямом смысле переписывается компилятором как `*(a + i)`. Так как `a + i == i + a`, то...
```c++
#include <iostream>

int main() {
    int a[5] = {0, 1, 2, 3, 4};
    std::cout << 3[a] << std::endl;  // just... why????
}
```

Даже `(-100)[a]` будет работать, никаких проблем не возникнет. Надеюсь, пояснять, почему так писать не надо, не требуется.

#### Многомерный массив

Чтобы получить массив с несколькими измерениями, нужно просто добавить ещё одни квадратные скобки справа.
```c++
int main() {
    int a[5][2] = {};  // first index goes 0..4, second goes 0..1

    for (ssize_t i = 0; i < 5; ++i) {
        for (ssize_t j = 0; j < 2; ++j) {
            std::cout << a[i][j] << ' ';
        }
        std::cout << std::endl;
    }
}
```

При этом, тип `a` - это `int[5][2]`.

#### Глубокий смысл синтаксиса указателей

Наверняка вы задавались вопросом: "А почему астериск можно написать в двух разных позициях, при этом он всё равно относится к переменной?"

**Пример:**
```c++
int main() {
    int *a, b;  // a is int*, b is int
    int* c;  // c is int*
}
```

Это сделано для того, чтобы указатели на более сложные типы (такие как массивы) можно было сделать очень тупым образом. Вместо переменной-названия `name` для типа `T` просто пишется `(*ptr_name)`, и это
в итоге создаёт указатель. Философия в том, что это соответствует разыменованию указателя: `name == (*ptr_name)`, и мы как-бы используем этот синтаксис, но в совершенно другом направлении мысли.

**Пример:**
```c++
#include <iostream>

int main() {
    int a[5] = {};
    int (*pa)[5] = &a;
    std::cout << pa;
}
```

Тип `pa` записывается как в объявлении переменной, просто нужно её имя убрать: `int (*)[5]`.

#### Массивы как аргументы функций

Жаль того человека, который это всё придумал. Дело в том, что здравый смысл здесь нас покидает. Когда функция принимает как аргумент любой массив, первая (она же внешняя) размерность всегда убирается и
тип воспринимается как указатель.

**Пример:**
```c++
void f(int a[3]) {
}

void f(int* a) {  // error: redefinition of f
}
```

**Пример:**
```c++
void f(int a[]) {
}

void f(int* a) {  // error: redefinition of f
}
```

**Пример:**
```c++
void f(int a[][3]) {
}

void f(int** a) {  // OK: the first version takes a, which is int (*)[3]
}
```

Всё настолько плохо, что в первых двух примерах массивы в самом прямом смысле являются указателями. То есть, `sizeof` вернёт размер указателя, а не массива. Также можно вместо массива указанной длины
передать любой другой (ведь аргумент буквально является простым указателем):
```c++
void f(int a[3]) {
   std::cout << a[0];
}

int main() {
   int b[5] = {5, 4, 3, 2, 1};
   f(b);  // it works!
}
```

И даже если бы размер `b` был меньше требуемого в аргументе, никакой проблемы бы не возникло.

### Динамические (Variable-Length-Array, VLA)

Для совместимости с C в нашем чудесном языке сохранены _динамические массивы_. Смех всей ситуации в том, что стандарт C++ ничего про эти массивы не говорит, но у всех они есть:
```c++
#include <iostream>

int main() {
   int n;
   std::cin >> n;
   int a[n];
   std::cout << a[0] << ' ' << sizeof(a);
}
```

В поведении нет никаких различий с обычными массивами, но только надо естественно иметь в виду, что такой массив вместо _стека_ оказывается на _куче_.

## Работа с памятью

### Чуток о куче

Стек, как известно, имеет ограниченный операционной системой размер. То есть, он может расти/уменьшаться, но есть определённая верхняя граница, дальше которой ему никуда не деться. На Linux, как правило,
это 8 MiB.

Возникает закономерный вопрос: "А что делать, если мне нужны объекты на гигабайты памяти?" На помощь приходит _оперативная память_ и такая её часть как _куча_. Без лишних слов: это просто память, которую
контролирует ОС, и можно просить её выделять какое-то количество памяти, а затем возвращать.

### C++ way: new & delete

Для работы с динамической памятью в C++ есть отдельные операторы: `new`/`delete` для переменных и `new[]`/`delete[]` для массивов.

**Пример:**
```c++
#include <iostream>

int main() {
    int* p = new int;  // p points to some heap memory
    *p = 3;
    std::cout << *p;
    delete p;  // returning memory to the OS
}
```

**Замечание:** любая современная ОС обладает защитой от ситуации, когда пользователь запросил память, а потом не вернул её (при этом процесс завершился). Но вот в старых ОС такого нет, поэтому если достать
и запустить программу с _утечкой памяти_ на условном MS-DOS, то часть выделяемой памяти _будет потеряна навсегда_ (до перезапуска ОС, если быть точным).

**Пример:**
```c++
#include <iostream>

void init_array(int n, int* p) {
   for (int i = 0; i < n; ++i) {
      p[i] = i;
   }
}

void output_array(int n, int* p) {
   for (int i = 0; i < n; ++i) {
      std::cout << p[i] << ' ';
   }
   std::cout << std::endl;
}

int main() {
   int n;
   std::cin >> n;
   int* p = new int[n];  // array of n elements

   init_array(n, p);
   output_array(n, p)

   delete[] p;
}
```

**Замечание:** `new` и `delete` прямо по-настоящему являются операторами. Убедиться можно по [таблице](https://en.cppreference.com/w/cpp/language/operator_precedence)

### C way: malloc & free

Если бы в C нельзя было тоже работать с динамической памятью, то Linux бы сегодня не существовало. Вместо операторов `new` и `delete` в этом старом языке есть такие функции как `malloc` и `free` соответственно.

**Пример:**
```c++
#include <iostream>
#include <cstdlib>

int main() {
   int* p = static_cast<int*>(std::malloc(sizeof(int)));  // malloc takes amount of bytes and returns void*

   if (p == nullptr) {  // if malloc failed, nullptr is returned
      return 1;
   }

   *p = 10;

   std::cout << *p << std::endl;

   std::free(p);
}
```

**Замечание:** можно обнаружить, что дописывать `std::` к этим функциям не обязательно. В целом да, но их наличие связано с тем, что в С нет и не было пространств имён. Плюс, на `std`-варианты этих функций
даются определённые [гарантии](https://en.cppreference.com/w/cpp/memory/c/malloc).

### calloc & realloc

`malloc` по факту возвращает _сырую память_ (указатель `void*`). Она ничем не инициализирована, нам просто даётся блок байтов согласно нашему запросу. Очевидно, бывают ситуации, когда мы хотим сделать чуть больше: проинициализировать
память сразу, или же расширить её с сохранением содержимого. Для этого есть `calloc` и `realloc` соответственно.

**Пример:**
```c++
#include <iostream>
#include <cstdlib>

int main() {
   int n = 10;
   int* p = static_cast<int*>(std::calloc(n, sizeof(int)));  // n elements of size (sizeof(int)) each are initialized with zero bits

   for (int i = 0; i < n; ++i) {
      std::cout << p[i] << ' ';
   }
   std::cout << endl;

   std::free(p);
}
```

**Пример:**
```c++
#include <iostream>
#include <cstdlib>

int main() {
   int* p = static_cast<int*>(std::malloc(sizeof(int)));

   int n;
   std::cin >> n;

   if (n < 1) {
      n = 1;
   }

   if (n > 1) {
      p = static_cast<int*>(std::realloc(p, n * sizeof(int)));  // reallocate memory so that we can put n int's inside of it
   }

   for (int i = 0; i < n; ++i) {
      p[i] = i;
   }

   for (int i = 0; i < n; ++i) {
      std::cout << p[i] << ' ';
   }
   std::cout << std::endl;

   std::free(p);
}
```


## C-style строки

## Что такое `main` и что оно умеет?

### Возвращаемое значение

### Аргументы `main`
