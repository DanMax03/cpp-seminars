# 3

## Оставшееся со 2го семинара

Напомню: UB = Undefined Behaviour. В других контекстах это сокращение значения не меняет. В ситуации с UB компилятор может лишь развести ручками, потому что это настолько широкий класс случаев, что никаких
разумных проверок для него придумать нельзя, да и даже отследить UB крайне трудно.

Поэтому, помимо UB есть другие классы ситуаций, когда от компилятора могут требовать _выдавать диагностику (предупреждения, ошибки)_.

### Unspecified Behaviour

В UB стандарт языка не даёт вообще никаких гарантий. Это значит, что программа может внезапно завершиться, или, например, ненарочно сломать вашу операционную систему. Однако есть ситуации, когда поведение
программы в каком-то смысле _случайно_, но у нас есть _понимание_, что в любой ситуации программа просто корректно отработает и тяжелых последствий не будет. Такие ситуации выносятся под категорию _unspecified
behaviour_.

**Важно:** компилятор _не обязан_ в своей спецификации объяснять, как именно разрешается тот или иной случай unspecified behaviour

**Пример:** порядок вычисления выражения определяется компилятором, но от этого плохо никому не становится (не должно, по крайней мере)
```c++
#include <iostream>

int f() {
   std::cout << "Hi, I'm f!" << std::endl;
   return 1;
}

int g() {
   std::cout << "Hi, I'm g!" << std::endl;
   return 2;
}

int h() {
   std::cout << "Hi, I'm h!" << std::endl;
   return 3;
}

int main() {
   f() + g() * h();  // value is well-defined, but the output of the program?... Any order is possible, and it's ok!
}
```

**Пример:**
```c++
#include <iostream>

void f(int x, int y) {
   std::cout << x << ' ' << y << std::endl;
}

int main() {
   int a = 1;
   f(++a, ++a);  // output? Again, unspecified behaviour
}
```

### Implementation-Defined Behaviour

Если спросить человека: "Какой размер у `int`?", то ответ 4 будет ошибкой. После продолжительного опыта использования языка должно быть известно, что такая деталь зависит от ОС и железа. Именно такие ситуации
относятся к implementation-defined behaviour, но без каких-либо дополнений это получится... просто unspecified behaviour?

**Важно:** компилятор _обязан_ в своей спецификации объяснять, как именно разрешается тот или иной случай implementation-defined behaviour

**Пример:** любой вызов `sizeof`

**Пример:** как известно, дробные числа (да и вообще все доступные в компьютере) сегодня записаны через двоичную систему чисел. Это приводит к тому, что часть из них невозможно точно представить. Так, литерал
`0.1f` компилятору придётся куда-то округлить. А куда, собственно? Это implementation-defined behaviour!

**Замечание:** к слову, тот факт что 1 байт = 8 бит - это тоже implementation-defined behaviour. Сама величина "байт" действительно стандартизовано, но бывают разные машины, где, например, [1 байт = 36 бит](https://en.wikipedia.org/wiki/PDP-10)

### Ill-Formed, No Diagnostics Required (IFNDR)

Язык C++ настолько богат, что существует возможность объявить функцию в одном файле, а определить уже в другом. Из-за этого компиляция файла без определения функции является вполне корректной вещью:
```c++
void f();

int main() {
   f();
}
```

### Errorneous behaviour (C++26)

Класс UB не требует (да и не может) никакой диагностики. Очевидно, для удобства жизни программистов было бы хорошо, чтобы таких ситуаций в языке было как можно меньше. Поэтому, из UB выделили дополнительную
часть под названием errorneous behaviour, которая включает в себя небольшую группу простых диагностируемых ошибок.

**Пример:**
```c++
#include <iostream>

int main() {
   int x;
   int y = x;  // errorneous behaviour, x is not initialized
   std::cout << y;
}
```

## Отслеживание ошибок

Язык C++ - сложный. Это уже привело к тому, что компилятор сообщает нам не о всех проблемах, которые могут быть в нашей программе (чтобы мы не утонули в их разборе). Однако, компилятор можно попросить явно
говорить о всех проблемах. Для этого есть флаг `-Wall`.

**Пример:** `clang++ -Wall main.cpp`

Также, можно попросить компилятор считать все предупреждения ошибками через `-Werror`.

Так как существуют разные компиляторы, то они могут делать некоторые вещи по-разному, а порой и добавлять свои особые детали в язык. Например, GNU GCC предоставляет структуру данных `pbds`, которую не найти в
остальных компиляторах. Для проверки, что ваш код может работать под любым компилятором (т.е. он _кросс-платформенный_), существует специальный флажок `-Wpedantic`, при включении которого компилятор расскажет
обо всех необычных деталях в вашей программе.

## Массивы

### На стеке

Из C в язык C++ перекочевал такой концепт как _массивы_. Это тип, который позволяет работать с несколькими объектами одного и того же типа, _непрерывно_ лежащими в памяти.

**Пример:**
```c++
#include <iostream>

int main() {
   int a[5] = {0, 1, 2, 3, 4};
   
   for (ssize_t i = 0; i < 5; ++i) {
      std::cout << a[i] << ' ';  // accessing i-th element via operator[]
   }
   std::cout << std::endl;
}
```

Тип переменной `a` в примере выше - `int[5]`, специальный тип для _массива из 5 элементов типа `int`_.

Также возможно указывать не все элементы массива при его инициализации:
 - `int a[5] = {0, 1, 2};` - последние 2 элемента будут проинициализированы по умолчанию (для `int` это ноль)
 - `int a[5] = {};` - все элементы будут проинициализированы по умолчанию
 - `int a[5];` - никакой элемент массива не будет проинициализирован, в них записан мусор.

У массивов есть свои особенности:
 1. Весь массив кладётся на стек. Это приводит к тому, что можно придумать очень простой пример переполнения стека:
    ```c++
    int main() {
       int a[10 * 1024 * 1024] = {};  // common stack size in Linux is 8MiB
    }
    ```
    Попытка запустить такую программу должна приводить к немедленному segfault.
 2. Массивы нельзя переприсваивать:
    ```c++
    int main() {
       int a[5] = {};
       int b[5] = a;  // CE
    }
    ```
 3. Вызов `sizeof` от объекта массива вернёт размер _всего массива в байтах_ (если у нас есть массив типа `T[n]`, то получим `n * sizeof(T)`):
    ```c++
    int main() {
       int a[5] = {};
       std::cout << sizeof(a) << std::endl;  // outputs 5 * sizeof(int), which is highly likely 20
    }
    ```
 4. Размер массива можно не писать, если он сразу инициализируется. Тогда компилятор посчитает размер за нас:
    ```c++
    int main() {
       int a[] = {1, 5, 8, 0};  // a has type int[4]
       for (int i = 0; i < 4; ++i) {
          std::cout << a[i] << ' ';
       }
       std::cout << std::endl;
    }
    ```

#### Array-to-pointer conversion

Как работают указатели? Они хранят адрес объекта соответствующего типа, а их инкремент/декремент даёт адрес на _непосредственно следующее/предыдущее_ место в памяти, где может лежать объект того же типа. Это в точности
та непрерывность, о которой говорится в массивах. Значит, мы в целом могли бы работать с массивами, просто используя указатель, скажем, на его начало.

Именно в этом заключается array-to-pointer conversion: мы можем работать с объектом массива как с указателем, и при необходимости будет всегда совершаться неявное преобразование к указателю.

**Пример:**
```c++
#include <iostream>

int main() {
   int a[5] = {1, 1, 3, 5};
   std::cout << *a << std::endl;  // a is converted to int* and then dereferenced
   std::cout << *(a + 3) << std::endl;  // a is converted to int*, summed with 3, and then dereferenced
}
```

**Замечание:** на самом деле, обращения к элементу C-массива не существует. Запись `a[i]` в самом прямом смысле переписывается компилятором как `*(a + i)`. Так как `a + i == i + a`, то...
```c++
#include <iostream>

int main() {
    int a[5] = {0, 1, 2, 3, 4};
    std::cout << 3[a] << std::endl;  // megalul
}
```

Даже `(-100)[a]` будет работать, никаких проблем не возникнет. Надеюсь, пояснять, почему так писать не надо, не требуется.

#### Многомерный массив

Чтобы получить массив с несколькими измерениями, нужно просто добавить ещё одни квадратные скобки справа.
```c++
int main() {
    int a[5][2] = {};  // first index goes 0..4, second goes 0..1

    for (ssize_t i = 0; i < 5; ++i) {
        for (ssize_t j = 0; j < 2; ++j) {
            std::cout << a[i][j] << ' ';
        }
        std::cout << std::endl;
    }
}
```

При этом, тип `a` - это `int[5][2]`.

#### Глубокий смысл синтаксиса указателей

Наверняка вы задавались вопросом: "А почему астериск можно написать в двух разных позициях, при этом он всё равно относится к переменной?"

**Пример:**
```c++
int main() {
    int *a, b;  // a is int*, b is int
    int* c;  // c is int*
}
```

Это сделано для того, чтобы указатели на более сложные типы (такие как массивы) можно было сделать очень тупым образом. Вместо переменной-названия `name` для типа `T` просто пишется `(*ptr_name)` ровно в том же
месте, и это в итоге создаёт указатель. Философия в том, что это соответствует использованию указателя, его разыменованию: `name == (*ptr_name)`. Объявление `T *p` тогда читается как "указатель, который при разыменовании
даёт тип `T`".

**Пример:**
```c++
#include <iostream>

int main() {
    int a[5] = {};
    int (*pa)[5] = &a;
    std::cout << pa;
}
```

Тип `pa` записывается как в объявлении переменной, просто нужно её имя убрать: `int (*)[5]`.

#### Массивы как аргументы функций

Жаль того человека, который это всё придумал. Здравый смысл здесь нас покидает. Когда функция принимает как аргумент любой массив, первая (она же внешняя) размерность всегда убирается и
тип воспринимается как указатель.

**Пример:**
```c++
void f(int a[3]) {
}

void f(int* a) {  // error: redefinition of f
}
```

**Пример:**
```c++
void f(int a[]) {
}

void f(int* a) {  // error: redefinition of f
}
```

**Пример:**
```c++
void f(int a[5][3]) {
}

void f(int** a) {  // OK: the first version takes a, which is int (*)[3]
}
```

Всё настолько плохо, что в первых двух примерах массивы в самом прямом смысле являются указателями. Например, `sizeof` вернёт размер указателя, а не массива. Также можно вместо массива указанной длины
передать любой другой (ведь аргумент буквально является простым указателем):
```c++
void f(int a[3]) {
   std::cout << a[0];
}

int main() {
   int b[5] = {5, 4, 3, 2, 1};
   f(b);  // it works!
}
```

И даже если бы размер `b` был меньше требуемого в аргументе, никакой проблемы бы не возникло.

## Работа с памятью

### Чуток о куче

Стек, как известно, имеет ограниченный операционной системой размер. То есть, он может расти/уменьшаться, но есть определённая верхняя граница, дальше которой ему никуда не деться. На Linux, как правило,
это 8 MiB.

Возникает закономерный вопрос: "А что делать, если мне нужны объекты на гигабайты памяти?" На помощь приходит _оперативная память_ и такая её часть как _куча_. Без лишних слов: это просто память, которую
контролирует ОС, и процессам можно просить её выделять на какое-то количество памяти, а затем они должны её возвращать.

**Замечание:** ситуация, когда процесс _забывает_ вернуть выделенную память, называется *утечкой памяти*. Такие ситуации являются одними из основных ошибок в программировании на C/C++, в силу просто отсутствия
какой-либо защиты от них. Любая современная ОС обладает защитой от ситуации, когда пользователь запросил память, а потом процесс завершился и эта память не была возвращена. Но вот в старых ОС такого нет, поэтому если достать
и запустить программу с утечкой памяти на условном MS-DOS, то часть выделяемой памяти _будет потеряна навсегда_ (до перезапуска ОС, если быть точным).

### C++ way: new & delete

Для работы с динамической памятью в C++ есть отдельные операторы: `new`/`delete` для переменных и `new[]`/`delete[]` для массивов. Первые из пар всегда возвращают указатель на начало соответствующей памяти, и такой же указатель
(то есть на начало когда-то выделенной памяти) нужно передавать в `delete` и `delete[]`.

**Пример:**
```c++
#include <iostream>

int main() {
    int* p = new int;  // p points to some heap memory
    *p = 3;
    std::cout << *p;
    delete p;  // returning memory to the OS
}
```

**Пример:**
```c++
#include <iostream>

void init_array(int n, int* p) {
   for (int i = 0; i < n; ++i) {
      p[i] = i;
   }
}

void output_array(int n, int* p) {
   for (int i = 0; i < n; ++i) {
      std::cout << p[i] << ' ';
   }
   std::cout << std::endl;
}

int main() {
   int n;
   std::cin >> n;
   int* p = new int[n];  // array of n elements

   init_array(n, p);
   output_array(n, p)

   delete[] p;
}
```

**Замечание:** `new` и `delete` прямо по-настоящему являются операторами. Убедиться можно по [таблице](https://en.cppreference.com/w/cpp/language/operator_precedence)

**Замечание:** зачем нужно 2 отдельных оператора для единичных объектов и массивов? Ну, здесь можно было бы задуматься о тонкостях реализации. Когда нужна память под один объект, мы по сути знаем её заранее за счёт
`sizeof(T)`, но это не так для массивов. Значит, для массива нужно где-то дополнительно записывать количество элементов, чтобы потом корректно удалять память по указателю. Хранить эту информацию в случае 1 элемента,
очевидно, странное решение.

**Пример:** удаление памяти неправильным оператором является UB
```c++
int main() {
   int n;
   std::cin >> n;
   int* p = new int[n];

   delete p;  // UB
}
```

### C way: malloc & free

Если бы в C нельзя было тоже работать с динамической памятью, то Linux бы сегодня не существовало. Вместо операторов `new` и `delete` в этом старом языке есть такие функции как `malloc` и `free` соответственно. Они
значительно отличаются от новых операторов:
```c++
void* malloc(size_t byte_count);
int free(void* ptr);
```

`malloc` возвращает `nullptr`, если выделить память не удалось. Аналогично `free` возвращает ненулевое значение (так называемый _код ошибки_), если память не удалось по какой-то причине очистить. Эти функции ничего
не знают о типах: они работают с чисто байтовыми кусками памяти, а указатель всегда (будь то возвращаемый в `malloc` или передаваемый в `free`) стоит на начале соответствующего отрезка памяти.

**Пример:**
```c++
#include <iostream>
#include <cstdlib>

int main() {
   int* p = static_cast<int*>(std::malloc(sizeof(int)));  // malloc takes amount of bytes and returns void*

   if (p == nullptr) {  // if malloc failed, nullptr is returned
      return 1;
   }

   *p = 10;

   std::cout << *p << std::endl;

   std::free(p);
}
```

**Замечание:** можно обнаружить, что дописывать `std::` к этим функциям не обязательно. В целом да, но их наличие связано с тем, что в С нет и не было пространств имён. Плюс, на `std`-варианты этих функций
даются определённые [гарантии](https://en.cppreference.com/w/cpp/memory/c/malloc).

### calloc & realloc

`malloc` по факту возвращает _сырую память_ (указатель `void*`). Она ничем не инициализирована, нам просто даётся блок байтов согласно нашему запросу. Очевидно, бывают ситуации, когда мы хотим сделать чуть больше: проинициализировать
память сразу (занулить её), или же расширить её с сохранением содержимого. Для этого есть `calloc` и `realloc` соответственно.

**Пример:**
```c++
#include <iostream>
#include <cstdlib>

int main() {
   int n = 10;
   int* p = static_cast<int*>(std::calloc(n, sizeof(int)));  // n elements of size (sizeof(int)) each are initialized with zero bits

   for (int i = 0; i < n; ++i) {
      std::cout << p[i] << ' ';
   }
   std::cout << endl;

   std::free(p);
}
```

**Пример:**
```c++
#include <iostream>
#include <cstdlib>

int main() {
   int* p = static_cast<int*>(std::malloc(sizeof(int)));

   int n;
   std::cin >> n;

   if (n < 1) {
      n = 1;
   }

   if (n > 1) {
      p = static_cast<int*>(std::realloc(p, n * sizeof(int)));  // reallocate memory so that we can put n int's inside of it
   }

   for (int i = 0; i < n; ++i) {
      p[i] = i;
   }

   for (int i = 0; i < n; ++i) {
      std::cout << p[i] << ' ';
   }
   std::cout << std::endl;

   std::free(p);
}
```

**Замечание:** и в случае `delete`, и в случае `free` передача `nullptr` не является UB. В этой ситуации просто ничего не произойдёт.

## Variable-Length-Array (VLA)

Для совместимости с C в нашем чудесном языке сохранены _динамические массивы_. Смех всей ситуации в том, что стандарт C++ ничего про эти массивы не говорит, но у всех они есть:
```c++
#include <iostream>

int main() {
   int n;
   std::cin >> n;
   int a[n];
   std::cout << a[0] << ' ' << sizeof(a);
}
```

В поведении нет никаких различий с обычными массивами, но только надо естественно иметь в виду, что такой массив вместо _стека_ оказывается на _куче_.

## C-style строки

Наконец-то можно объяснить, что такое литерал `"abracadabra"` и где он находится. Это так называемые C-строки, которые очевидно остались с языка C. В памяти они представляют собой
массив `char`'ов, к которому в конце обязательно приписан _стандартный символ конца строки_ - `'\0'`. Также, все строковые литералы сохраняются в статической секции памяти программы,
то есть их нельзя изменить!

**Пример:**
```c++
int main() {
   char* s = "abc";
   s[0] = 'd';  // UB. Warning or CE if the compiler is good enough
}
```

**Пример:** как известно, вывод массива/указателя отображается как его адрес. Но для строк (а именно `char*`) сделана специальная перегрузка
```c++
int main() {
   std::cout << "Hello, world!" << std::endl; 
}
```

**Замечание:** если хочется узнать адрес строки, то всегда можно сделать приведение к `void*`.

**Замечание:** любая C-функция, предназначенная для работы со строками, будет опираться на знание о таком символе. Если создать руками свою строку без этого символа, то вызов любой
подобной функции будет просто UB
```c++
#include <iostream>

int main() {
   char s[] = {'H', 'e', 'l', 'l', 'o'};
   std::cout << s;  // UB!
}
```

### Полезные строковые C-функции

 - [strlen](https://en.cppreference.com/w/cpp/string/byte/strlen) - вычисление длины данной строки
 - [strcpy](https://en.cppreference.com/w/cpp/string/byte/strcpy) - копирование строки в буфер (при этом буфер должен быть способен вместить строку!)

**Замечание:** `strcpy` работает медленно, ибо ему приходится проверять каждый символ на конец строки `\0`. Поэтому, часто вместо этой функции используют
[memcpy](https://en.cppreference.com/w/cpp/string/byte/memcpy).

**Важно:** `memcpy` не гарантирует корректного поведения, если отрезки памяти, на которые указывают `src` и `dest` пересекаются. Если нужно копирование в такой ситуации, есть [memmove](https://en.cppreference.com/w/cpp/string/byte/memmove)

## Что такое `main` и что оно умеет?

`main` - это особая функция в программе C++, с которой всегда начинается исполнение.

### Возвращаемое значение

У `main` всегда присутствует возвращаемое значение. Что это, куда оно уходит и где используется? Оказывается, это связано с операционными системами и концепцией процесса. Процесс при завершении должен
сообщить свой _статус_, то есть завершился ли он успешно, или произошла ошибка. Именно этот статус возвращается в `main`. По соглашению, 0 всегда считается статусом успеха, а всё остальное - ошибкой

```c++
int main() {
   return 1;
}
```

**Замечание:** в консоли можно узнать статус последней исполненной команды при помощи переменной `$?`. Например, можно вывести этот статус на экран через `echo $?`

**Замечание:** возможность не дописывать в `main` классическое `return 0;` появилась в стандарте C99. Если последний statement не является `return`'ом, то компилятор автоматически допишет его за вас

### Аргументы `main`

Когда программа запускается через консоль, ей можно сразу передать какие-то аргументы: `cat file.txt`. Чтобы получить доступ к этим аргументам, есть версия `main` с двумя аргументами:
```c++
#include <iostream>

int main(int argc, char* argv[]) {  // default names: argc = argument count, argv = argument values
   for (int i = 0; i < argc; ++i) {
      std::cout << i << ": \"" << argv[i] << "\"" << std::endl;
   }
}
```

**Важно:** нулевым аргументом всегда идёт команда, при помощи которой была запущена программа, а остальные аргументы естественно идут потом.
