# 1

## Linux

### Мотивация

1. Учеба. На втором и третьем курсе вас ждут такие замечательные предметы как АКОС (Архитектуры Компьютеров и Операционных Систем),
ТиПМС (Теория и Практика Многопоточной Синхронизации), Параллельные и распределенные вычисления. Везде в этих курсах вы неизбежно столкнётесь
с Linux по ряду причин:
   1. На АКОС мы изучаем ОСи на примере Linux
   2. Для Concurrency (он же ТиПМС) вам потребуются _санитайзеры_ и прочие прелести, которые в полной форме есть исключительно на Linux
   3. Вам потребуется удалённо подключаться к Linux-машине в рамках задач
   4. Отладка на Windows, как известно, разваливается при малейшем чихе

2. Работа. Практически все современные сервера работают на Linux, ибо это быстро и значительно лучше во многих аспектах, чем Windows
(как минимум open-source). В итоге, вам
   - Либо придётся работать с корпоративным ноутбуком на Linux
   - Либо придётся подключаться к удалённым машинам, работающим под Linux

### Беглый обзор команд и концепций

Самая важная команда в Linux - это `man`, команда открытия документации (MANuals)

 - `man man` - документация к `man`
 - `man <something>` - документация к набранной вами `<something>`
   **Пример:** `man cd`

#### Файловая система

_Файлом_, вообще говоря, считаются любые объекты, к которым можно как-то определить операции чтения, записи и исполнения (это неформальное определение,
но я его даю скорее к тому, что файл в Linux - это не только какой-нибудь исходник плюсовой программы)

В Linux файловая система _древовидная_ (образует ориентированное дерево):
Не успели обсудить :(
 - Директории образуют промежуточные вершины
 - Остальные файлы являются _листьями_ (с некоторыми оговорками)
 - Вершина A будет потомком B, если в директории B содержится A
 - Папка `/` является корнем файловой системы
 - Каждая директория имеет ребро в себя и в своего родителя. Это выражается через наличие поддиректорий `.` и `..` соответственно

**Пример:** (папки `.` и `..` намеренно опущены)
```
           '/'
           / \
      'home' 'bin' ------\
      /         \         \
   'daniil'     'env'    'sh'
      |
'some_file'
```

К любому файлу в Linux можно адресоваться посредством _пути_. Вариантов 2:
 - Абсолютный путь `/home/daniil/my_text_file` (невероятно, начинается от корня)
 - Относительный путь `./build/my_program` (путь до исполняемого файла `my_program` относительно текущей директории)

Ну, а теперь пора к командам для работы с файловой системой:
 - `pwd` - вывести абсолютный путь до текущей директории (Print Working Directory)
 - `cd` - сменить директорию (Change Directory)
 - `ls` - вывести содержимое директории
 - `mkdir` - создать директорию (MaKe DIRectory)
 - `touch` - создать файл
 - `rm` - удалить файл (ReMove)
 - `mv` - переместить файл (MoVe)
 - `cp` - скопировать файл (CoPy)

#### Пользователи

Linux устроен так, что в нём может быть множество _пользователей (users)_ (воспринимайте как некоторый аккаунт, учетную запись). Эти пользователи
могут объединяться в _группы (groups)_. Всё это нужно в целях администрирования.

 - `users` - вывести список всех пользователей на экран
 - `groups` - вывести список всех групп на экран
 - `whoami` - узнать текущего пользователя

#### Пользователи и файлы

Есть особая директория - `~`. Строго говоря, это просто второе название для _стартовой директории (то, где вы оказываетесь при запуске терминала)_.
Её полный вид можно узнать, например, так:
```bash
cd ~
pwd
```

Как правило, это `/home/<username>`

У файлов есть связанный с ними пользователь (он же _владелец_) и группа. В Linux можно настроить права чтения, записи, и исполнения
для следующих обращений:
1. Обращение от владельца
2. Обращение от члена группы
3. Обращение от _внешнего_ пользователя (того, кто не находится ни в группе, ни является владельцем)

Увидеть текущие права на файле можно, например, если вывести информацию о нём через `ls -l`. В первом столбец будет маска а-ля `drwxrwxrwx`
 - Первый символ отвечает за тип файла. `-` - обычный файл, `d` - директория, `l` - символьная ссылка (есть и другие, но не будем об этом)
 - Далее следует три группы прав. В каждой есть ровно 3 символа (`r` - право чтения, `w` - право записи, `x` - право исполнения). Они
 соответствуют владельцу, группе, и внешним пользователям соответственно (если какого-то права нет, вместо него будет стоять `-`)

**Пример:** `-rw-r---w-` - это обычный файл, владелец которого может и читать, и писать в него. Пользователи из соответствующей группы
могут только читать, при этом внешние пользователи способны записывать информацию в этот файл.

Чтобы поменять права на файл, используется команда `chmod`.

#### Исполняемые файлы

Чтобы исполнить программу, лежащую в папке, нужно ввести в консоль не её название, а путь до неё

**Пример:** пусть у меня есть исполняемый `a.out` в текущей папке. Если написать в консоль
```
a.out
```
То чуда не произойдёт. Если же написать
```
./a.out
```
Всё заработает.

А как именно исполняется файл? Как Linux понимает, что вообще с ним делать? ОС читает файл и на основе некоторых деталей понимает, что надо
сделать:
 - Если файл в бинарном формате, у него будет так называемый _ELF-заголовок_
 - Если файл начинается с символов `#!` (так называемый _шебанг_, shebang), то ОС возьмёт остаток от той же строки и попытаётся интерпретировать это как команду,
 которой нужно передать этот файл
 - Иначе, Linux будет считать, что файл надо запускать интерпретатором терминала

**Пример:**
```bash
#!/usr/bin/env bash

echo "Hello, world!"
```

**Пример:**
```python
#!/usr/bin/env python

s = 'Hello, world!'
print(s)
```

#### Процессы

Процесс - это то, чем в Linux называется экземпляр запущенной программы.

Процессы можно увидеть при помощи таких команд как `top`, `htop` или `ps`. Процессы занумерованы, каждому присвоен идентификатор (pid - process id).

Процессы, как и файлы, организованы в древовидную иерархию. Как правило, корневым процессом будет `systemd` или `init`.

Терминал - это тоже процесс. Когда мы пишем какую-либо команду в нём, мы на самом деле запускаем ещё один (дочерний) процесс и _следим за ним_.

Процессы умеют общаться между собой посредством _сигналов_. Чтобы послать сигнал конкретному процессу из терминала, используют `kill`.

**Пример:** `kill -9 <process_id>` - принудительно завершить процесс

Для некоторых сигналов к дочернему процессу из терминала есть горячие клавиши:
 - `Ctrl + C` - послать `SIGKILL` дочернему процессу
 - `Ctrl + Z` - послать `SIGSTOP` дочернему процессу

После `SIGSTOP` дочерний процесс можно запустить дальше:
 - `fg` - запустить и продолжить наблюдать
 - `bg` - запустить и перестать наблюдать (сможем выполнять команды в терминале)

#### Суперпользователь

В Linux всегда присутствует хотя бы один пользователь. Он особенный - `root`. Пользователь `root` не обращает внимания на ограничения и разрешения,
необходимые всем остальным. Ему доступно всё.

 - `sudo <your_cmd>` - запуск процесса от имени суперпользователя (super user do)

#### Установка программ

В Linux очень любят говорить про _пакеты_. По сути, это то же самое, что и программы в Windows. Если в используете Ubuntu, то у вас есть
пакетный менеджер `apt`. Чтобы установить что-либо, вам нужна команда `sudo apt install <package>`

## О редакторе для курса

Глобально, варианта 2: либо ПО от JetBrains (CLion), либо Vim (или Neovim, что лучше :) ).

Причина в том, что вам рано или поздно потребуются реальные способности, связанные с LSP (подсветка, подсказки), а для большинства
текстовых редакторов среда плагинов будет крайне скудной (у них может этого всего просто не быть, либо в какой-то очень узкой форме).

 - CLion - решение из коробки, всё будет работать сразу (рекомендуется)
 - Neovim - можно установить сразу какой-нибудь LazyVim, либо придётся учиться разбираться Lua-конфигурации и делать всё самим

## Полезные программы

- `vimtutor` - очень классный способ заботать vim в деталях за 30-60 минут
- `tree` - более приятное глазу графическое представление `ls -lR`

## Полезные ссылки

- [Бесплатный курс по Linux](https://stepik.org/course/73/promo) - рекомендую быстренько пройти, чтобы набить руку на командах
- [Сайт с реально полезными шпорами по разным программам и языкам](https://devhints.io/)

