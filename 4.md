# 4

## Сложные объявления

### Функциональный тип

Невероятно, но факт: у функций тоже есть свой тип! Его можно получить, если взять произвольное объявление функции, и убрать оттуда любые названия (так
же известные как id).

**Пример:**
```c++
int interestingSum(int a, int b) {
    if (a == 0 && b == 0) {
        std::abort();
    }

    return a + b;
}

// Type of 'interestingSum' is int(int, int)
```

**Замечание:** В теории типов есть такое понятие, как [объекты первого класса](https://en.wikipedia.org/wiki/First-class_citizen). Для
нашего любимого языка это любой объект, который можно принимать в функцию, возвращать из функции, делать над ним обычные операции в обычных выражениях
(ну прямо как `2 + 3`). Несложно заметить, что типы в C++ не относятся к такой категории объектов. А ещё к этой категории относятся функции. Невозможно
написать функцию, которая бы возвращала другую функцию:
```c++
void() f(int x);  // wait, that's illegal
```
Более того, функции являются [синглтонами](https://en.wikipedia.org/wiki/Singleton_pattern). Их нельзя как-то вручную создать (кроме как написать определение),
скопировать и всё в таком духе:
```c++
#include <iostream>

void f() {
    std::cout << "Hello, world!" << std::endl;
}

int main() {
    void() g = f;  // CE
}
```

### Указатель на функцию

Тем не менее, в языках C/C++ есть возможность брать указатель на функцию. И вот тогда, в каком-то смысле, мы можем их и копировать, и создавать. Объявление
указателя следует всё то же философии "разыменование указателя даёт тип T, на который он и указывает":
```c++
#include <iostream>

int strangeSum(unsigned a, unsigned b) {
    while (b > 0) {
        ++a;
        --b;
    }

    return a;
}

int main() {
    int (*f_ptr)(unsigned, unsigned) = &strangeSum;

    std::cout << (*f_ptr)(10, 10) << std::endl;
}
```

**Замечание:** в языках C/C++ присутствует синтаксический сахар для указателей на функции. При вызове функции через указатель, вообще говоря, можно не делать
разыменования: `f_ptr(10, 10)` - тоже корректная запись для последнего примера

### Комбинирование объявлений. Выражения над типами

**Пример:** указатель на функцию, принимающую массив целых чисел и массив указателей на функции, принимающих 1 число и ничего не возвращающих
```c++
void (*ptr)(int[], void (*[])(int)) = nullptr;
```
Добро пожаловать в проклятый мир, что мы сами и создали. Как это читать, как с этим жить?

Далее материал описан с опорой на [эту замечательную ссылку](http://unixwiz.net/techtips/reading-cdecl.html)

Если глубоко задуматься, то можно заметить следующий факт: в языке C/C++, хоть и в каком-то кривом виде, но присутствуют _выражения над типами_. Если раньше мы
комбинировали, условно говоря, переменные при помощи обычных операторов `+`, `-` и так далее, то теперь мы комбинируем _типы_ при помощи... каких операторов? А
их у нас 3, вот они слева-направо:
 - Оператор указателя `*`
 - Оператор C-массива `[]` (конечно же, внутри скобок можно писать размер, но в обозначении оператора я его просто опускаю)
 - Оператор функции `()` (аналогично предыдущему, тут конечно же могут быть аргументы функции внутри скобок)

Чтобы как-то работать с выражениями над типами, нам нужно задать _порядок применения операторов_ (такой же, как и для [обычных](https://en.cppreference.com/w/cpp/language/operator_precedence)):
 1. `[]` и `()`, всегда слева-направо для подряд идущих `[]` (функции не могут возвращать функции, поэтому подряд идущих `()` просто нет)
 2. `*`, всегда справа-налево

Для _инфиксных_ операторов (таких как `+` в выражении `2 + 3`) мы знаем, как их переписать в _явной форме_ (`operator+(2, 3)`). Аналогично, введём явные обозначения
для наших операторов над типами (для отличия от функций, я буду использовать треугольные скобочки):
 - `pointer<T>` соответствует `T*`
 - `c_array<T, N>` соответствует `T[N]`. Если второй аргумент опущен, то подразумевается `T[]`
 - `c_func<T, Arg1, Arg2, ...>` соответствует `T(Arg1, Arg2, ...)`

Когда мы читаем какой-то сложный тип, мы идём _снаружи внутрь_. Это логично, достаточно посмотреть любой пример (указатель на что-то, массив чего-то, функция принимает то-то и возвращает это). Поэтому
важно уметь понимать, где находится конец выражения над типами, чтобы раскрутить его во внутрь. И вот тут-то наступает проблема с нашими операторами в исходном синтаксисе. Чтобы их соединять, нужно
подчиняться фИлОсОфИи с указателями:
```c++
int (*)(int, int);  // it would be logical to see int(int, int)*, which can also be seen as pointer<c_func<int, int, int>>
int (*)[];          // it would be logical to see int[]*, which can also be seen as pointer<c_array<int>>
int ([])(int);      // it would be logical to see int(int)[], which can alse be seen as c_array<c_func<int, int>>
```
То есть, каждый оператор каждый раз "выворачивает наизнанку" наше выражение. Вместо того, чтобы искать конец выражения, как полагается, в синтаксическом конце (то есть справа), мы вынуждены искать
его где-то в глубине... Но не всё так плохо: место конца типа является тем же местом, куда мы пишем имя переменной.

**Правило 1:** чтение любого объявления нужно начинать с позиции, в которой пишется имя переменной.

**Замечание:** из-за такого странного правила композиции операторов над типами, если попросить компилятор вывести на экран тип массива или функции, то часто добавляются чисто синтаксические
скобки `T ()[]` или `T ()(Arg1, Arg2, ...)`.

**Пример:** читаем исходя из объявления пример выше
 1. В скобках, где написано имя, есть только указатель. Значит, в явной форме тип синтаксически начинается с `pointer<...>`
 2. Вне скобок написан функциональный оператор. Значит, дальше будет `pointer<c_func<...>>`. Остаётся сопоставить типы для функционального оператора, получим
 ```c++
 pointer<c_func<void, int[], void (*[])(int)>>
 ```

Есть более простое правило, как читать такие объявления:

**Правило 2:** иди вправо, пока можешь, иди влево, когда должен

Оно соответствует нашей таблице приоритетов: всегда в рамках выражения мы вначале работаем с `[]` и `()`, а только потом идём по оператору `*`

### Ссылка как оператор над типом

Ссылка тоже по факту является оператором над типом. По историческим причинам, её синтаксис в точности совпадает с `*`, даже в комбинации с другими операторами:
```c++
void f(int);
void g(int);

int main() {
    void (&fun_ref)(int) = f;  // just ._.
}
```

**Замечание:** в процессе подготовки к семинару я совершенно случайно обнаружил, что _ссылка на массив_ в аргументе функции ведёт себя совершенно иначе, чем просто аргумент массива! А именно, передача
массива таким образом не приводит к потере никаких свойств массивов:
```c++
#include <iostream>

void f(int (&c_arr)[4]) {
    std::cout << sizeof(c_arr);  // outputs 16
}

int main() {
    int a[4] = {};
    f(a);
}
```

## Компиляция в деталях

Настало время узнать правду о компиляции C++ программ. А именно, какие этапы входят в этот процесс:
 1. Preprocessing
 2. Compilation
 3. Assembling
 4. Linking

**Замечание:** процесс компиляции содержит стадию компиляции, интересно конечно...

### Preprocessing

Preprocessor - это часть компилятора, которая умеет преобразовывать исходный код программы. Он всегда исполняется сверху вниз по исходному коду программы и, в частности, умеет вставлять/вырезать какой-либо код.

Любая команда препроцессора выглядит как `#command arguments`. Упомяну самые популярные:
 - `#include path` - вставить в исходный код программы всё содержимое другого файла
 - `#define token expression` - заменять _почти любое_ вхождение `token` в коде программы ниже на `expression`
 - `#pragma` - передать указание для компилятора

Помимо этого, в препроцессоре есть ветвления. Есть `#if`, но более важным я бы считал `#ifdef`.

**Пример:**
```c++
#ifdef ABOBA
// this code is included in file if ABOBA is defined

void f() {
    std::cout << "ABOBA is here!" << std::endl;
}

#else
// thi code is included in file if ABOBA is NOT defined

void f() {
    std::cout << "ABOBA?" << std::endl;
}

#endif
```

Аналогично есть `#ifndef`, где `n` стоит для `not`

**Замечание:** чтобы остановить компиляцию после этапа препроцессинга, нужно воспользоваться флагом `-E`

### Compilation

Золотой вопрос: а что было до языка C? Что было до момента, когда мы научились в принципе делать какие-то среднеуровневые языки? На чём они построены? Ответ
на этот вопрос, в целом, простой - Assembler.

Процессор в компьютере понимает исключительно машинный код, но писать осознанные нолики и единички для человека невероятно трудно, поэтому в прошлом пришли
к такой идее, что надо _закодировать процессорные команды_ в некоторые _мнемоники_ (человекочитаемые процессорные команды). Всё, чем занимаются ассемблеры -
это прямое переписывание мнемоник в соответствующие битовые представления.
```asm
mov rax, 1;   // put 1 in rax register
mov rbx, 10;  // put 10 in rbx register
add rbx;      // add rbx to rax and store the result in rax
```

**Замечание:** обычно, под каждую архитектуру имеется свой ассемблер, причём допустимые инструкции этого ассемблера могут варьироваться в зависимости от модели
процессора на данной архитектуре

**Замечание:** увидеть, во что превращается высокоуровневый код на C++ на уровне ассемблера на разных архитектурах можно на сайте godbolt.org

**Замечание:** чтобы остановить компиляцию после этапа компиляции в asm, нужно воспользоваться флагом `-S`

### Assembling

Ассемблирование - это просто переход от ассемблерного представления программы к машинному коду. Получившийся файл после этой стадии называют _объектным файлом_. Как
правило, у них ставят расширение `.o`.

**Замечание:** Разделение стадий компиляции в ассемблерный код и ассемблирования сделано для того, чтобы была возможность применять оптимизации под конкретную архитектуру железа. Как
правило, обычному программисту эта стадия не даёт никакой информации.

**Замечание:** чтобы остановить компиляцию после этапа превращения в объектный файл, нужно воспользоваться флагом `-c`

### Linking

Объектный файл, полученный результате ассемблирования, всё ещё не является итоговой программой, даже если ему вручную дать право на исполнение. Происходит это из-за того, что программой на C++
может быть далеко не один файл `main.cpp`, а сразу несколько, причём они могут быть связаны между собой. Каждый такой файл представляет собой _единицу компиляции (compilation unit)_.

**Пример:** для компиляции надо вызвать `clang++ main.cpp foo.cpp`
```c++
// foo.cpp
#include <iostream>

void foo() {
    std::cout << "Hello from foo!" << std::endl;
}

// main.cpp
void foo();

int main() {
    foo();
}
```

Отсюда возникает сразу несколько вопросов и ответы на них:
 1. Зачем нужны объявления? Объявления нужны для того, чтобы можно было проверять типы в одной единице компиляции без необходимости ходить куда-то в другой файл
 2. Как работают пространства имён в C++ программе? На этапе линковки все простраства из разных единиц компиляции объединяются согласно их имени (будем считать, что у глобального пространства просто
 пустое имя)

Ну а главный вопрос: а как связаны этапы и программа с несколькими единицами компиляции? Ответ: первые 3 этапа происходят параллельно с каждой единицей компиляции, а дальше вступает в своё дело _линкер_.

Linker - это подпрограмма компилятора, которая отвечает за связывание имён из разных единиц компиляции друг с другом.

Так как задача связывания имён достаточно нетривиальная, а стандарт толком ничего не говорит об этом, то практически любая ошибка на этапе линковки - это IFNDR

**Пример:** забытое определение, которого нет даже в другой единице компиляции
```c++
void foo();

int main() {
    foo();
}
```

**Замечание:** чтобы остановить компиляцию после этапа линковки, вам не нужны флаги :)

#### Заголовочные файлы

В силу One Definition Rule, мы не пишем определения в файл, которые предполагается `#include`-ить, потому что всего 2 таких случая приведут к нарушению этого правила.

Всё вышесказанное привело в своё время к следующему разделению кода программ:
 - Всяческие _объявления_ выносятся в _заголовочные файлы_. Как правило, они имеют расширение `.h`/`.hpp`
 - _Все определения_ пишутся в _исходные файлы_. Как правило, они имеют расширение `.c`/`.cpp`

**Пример:** ODR violation
```c++
// foo.hpp
int foo() {
    return 42;
}

// gee.cpp
#include "foo.hpp"

int gee() {
    return foo() * 2;
}

// main.cpp
#include <iostream>
#include "foo.hpp"

int main() {
    std::cout << gee() << std::endl;
}
```

#### Ключевое слово `extern`

Как видно из примеров выше, мы можем абсолютно никак не помечать тот факт, что объявленная сущность будет находится в другой единице компиляции. Чтобы дать явную подсказку
программисту, ввели ключевое слово `extern`. Его стоит просто писать как хороший тон там, где мы намерены вызывать функцию/переменную вне нашей единицы компиляции.

**Пример:** откройте заголовок `<iostream>` и посмотрите объявления `std::cin`, `std::cout`

## Полезные ссылки

 - [Reading C type declarations]()
