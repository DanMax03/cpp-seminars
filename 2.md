# 2

## Про выражения

В C++ есть 2 большие категории объектов - то, что можно применить (структуры) и то, к чему можно применить (функции). Любое выражение
таким образом является просто вызовом функции с аргументами-подвыражениями.

**Пример:** `f(x, g(), h(x, y, z))`

### Инфиксная запись

А что тогда такое `2 + 3`? Это _инфиксная запись оператора_. Об этом выражении всегда можно думать как о вызове `operator+(2, 3)`.

Выражение, записанное через явные функции (т.е. с учётом `operator+`) можно смотреть как на дерево:

```
            f
         /  |    \
        x   g     h
            |    /|\
           None  xyz
```

То есть, промежуточные вершины дерева - это функции, а потомки - аргументы к этой функции. Листьями в таком случае могут быть либо переменные, либо `None`
(просто обозначение для вызова функции без аргументов)

Если же пытаться строить деревья для выражений, имеющих инфиксные записи операторов, то можно столкнуться с неоднозначностью.

**Пример:** `1 + 2 + 3`. Этому выражению можно сопоставить 2 разных дерева:
```
   (1 + 2) + 3                           1 + (2 + 3)

         +                                    +
        / \                                  / \
       +   3                                1   +
      /\                                        /\
     1  2                                      2  3
```

Аналогичная ситуация произойдёт и в более плохом случае: `1 + 2 * 3`. Здесь, если компилятор не знал бы о _приоритете операций_, мы могли бы ожидать
2 разных значения у одного выражения!

Чтобы решить эту неоднозначность разбора, в языке задан [порядок на операторах](https://en.cppreference.com/w/cpp/language/operator_precedence).

**Пример:** из вышесказанного, выражение `std::cin >> a >> b >> c` воспринимается компилятором как `((std::cin >> a) >> b) >> c`

### Процесс вычисления

Как уже было озвучено выше, есть значения, а есть функции, которые можно вызвать и получить какой-то результат. Язык C++ - _нечистый_, в том смысле, что у
программы всегда есть некоторое глобальное состояние и контекст. Процесс вычисления результата функции состоит из двух частей:
 1. Непосредственные вычисления выражений, необходимых для итогового
 2. Побочные действия (например, изменение состояния каких-то объектов или вывод/ввод значений)
Подробно об этом можно прочитать [на этой странице](https://en.cppreference.com/w/cpp/language/eval_order)

Чтобы вычислить значение всего выражения (дерева), компилятор должен вычислить значение каждого подвыражения (поддерева). И вот тут начинается большой нюанс:
мы не можем в общем случае сказать, какие поддеревья компилятор должен вычислить первыми. Он в праве делать
[всё, что не изменяет поведения программы со стороны пользователя](https://en.cppreference.com/w/cpp/language/as_if).

Поэтому то, что мы записываем в выражения, по сути говорит компилятору только следующее: ты не можешь начать вычислять значение вызова функции, не вычислив аргументы.

## Интересные операторы

### Оператор запятой

Выражения можно писать через запятую: `x = 5, y = x` и это законно! Перед вами _оператор запятой_, который из нескольких выражений делает одно. Возвращаемое значение совпадает
со значением крайнего правого оператора.

**Замечание:** не нужно путать оператор запятой с вызовом функции. В вызове `f(x, y, z)` никакого оператора запятой никогда не было, нет и не будет!

**Замечание:** оператор запятой особенно отличается в вопросе того, в каком порядке компилятор вычисляет его подвыражения. Есть гарантия, что в `E1, E2` все побочные действия и вычисление `E1`
будут произведены до начала вычисления `E2`. Подробности [тут](https://en.cppreference.com/w/cpp/language/operator_other)

### Тернарный оператор

Тернарный оператор - это сокращённый вариант для написания ветвления в выражении: `(condition ? expr_true : expr_false)`. То есть, это аналогично вызову `foo123()`, где функция определена так:
```c++
T foo123() {
   if (condition) {
      return expr_true;
   } else {
      return expr_false;
   }
}
```

**Пример:** `result = n % 2 == 0 ? even_fact(n) : odd_fact(n)`

**Замечание:** тернарный оператор не вычисляет сразу оба результирующих выражений. Будет вычислено только то выражение, которое нужно. Это подтверждает
[страница на cppref](https://en.cppreference.com/w/cpp/language/operator_other).

**Замечание:** стоит отметить, что понятие "будет вычислено только то, что нужно" не совсем правдиво. На деле [всё немножко сложнее, ради скорости работы программы](https://en.wikipedia.org/wiki/Branch_predictor)

**Замечание:** как и любое выражение, тернарный оператор тоже задаёт выражение. А у него должна быть категория - либо lvalue, либо rvalue. Поэтому `expr_true` и `expr_false` должны иметь одну и ту же категорию,
которую унаследует новое выражение (иначе будет ошибка компиляции). Также новое выражение должно обладать каким-то типом. Есть [свод правил](https://en.cppreference.com/w/cpp/language/operator_other), по которым
он получается (в случае чисел будет происходить integer promotion)

## Ошибки компиляции (Compilation Errors)

### Маленький взгляд на процесс компиляции

В самом простом понимании, компилятор берёт на вход код программы и возвращает бинарный файл, который можно запустить. Пора немного приоткрыть завесу того, как это работает _на самом деле_:
 1. Лексер разбивает текст исходной программы на _токены_ - имена, конструкции языка, ещё что-то из его грамматики
 2. Парсер берёт разобранный исходный код и строит по нему AST (Abstract Syntax Tree) - синтаксическое дерево программы, похожее на то, что мы делали для выражений
 3. Backend берёт AST и строит по нему бинарный файл программы под данную архитектуру компьютера

### Классификация CE

В зависимости от того, на каком этапе возникла ошибка компиляции, ошибки разделяются на виды:
 1. Лексические
 **Пример:** недопустимое название переменной
 ```c++
 int main() {
    int \\ = 3;
 }
 ```

 2. Синтаксические
 **Пример:** незаконченная инфиксная запись оператора
 ```c++
 int main() {
    2 + ;
 }
 ```

 3. Семантические
 **Пример:** неопределённая операция над типами
 ```c++
 int main() {
    "abc" + 2.0f;
 }
 ```

 **Пример:** обращение к необъявленной переменной
 ```c++
 int main() {
    std::cout << x;
 }
 ```

 **Пример:** неоднозначное обращение к переменной
 ```c++
 namespace n1 {
    int x = 3;
 }

 namespace n2 {
    int x = 5;
 }

 int main() {
    using namespace n1;
    using namespace n2;

    std::cout << x;  // Moreover, commenting this line removes the error!
 }
 ```

## Ошибки времени исполнения (Runtime Errors)

Они бывают разными и часто зависят от того, про какую операционную систему мы говорим. Стоит знать несколько примеров:

**Пример:** segmentation fault (segfault, SIGSEG) из-за обращения в неизвестную память
```c++
#include <vector>

int main() {
   std::vector<int> v;
   std::cout << v[500000];
}
```

**Пример:** floating point exception (SIGFPE) в результате целочисленного деления на 0 (название сохранилось исторически)
```c++
int main() {
    int d;
    std::cin >> d;  // input d = 0
    std::cout << 1 / d;
}
```

**Пример:** abortion (SIGABT) в результате принудительного завершения исполнения, вызванное самой программой
```c++
   std::vector<int> v;
   std::cout << v.at(0);
```

**Замечание:** Для вызова SIGABT есть специальная функция `std::abort()`

## Неопределённое поведение (Undefined Behaviour)

Название UB говорит само за себя - это такие ситуации, в которых стандарт ничего не может сказать про поведение программы. Нам не даётся гарантия ни на компилируемость программы,
ни на её работоспособность.

Отсутствие UB в пользовательской программе - это фундаментальное соглашение, установленное Создателем между компилятором и программистом. Компилятор _верит, что в программе нет UB_.

**Замечание:** здесь можно вернуться к упомянутому в начале as-if rule. Чаще всего со стороны UB можно заметить тогда, когда программа компилируется с *оптимизациями*. Если UB нет, то
поведение программы не меняется, а иначе такой гарантии нет. Примеры дальше отлично это демонстрируют.

Чтобы скомпилировать программу с оптимизациями, можно добавить один из флагов `-O0` (без оптимизаций) `-O1`, `-O2`, `-O3` (чем выше уровень, тем больше оптимизаций) или `-Ofast`. Стоит
сказать, что оптимизации не всегда дают более быстрый код, поэтому при необходимости стоит производить замеры времени работы.

### Простые примеры

 1. *Небольшой* выход за границы массива:
 ```c++
 int main() {
    std::vector<int> v(1);
    std::cout << v[2];  // highly likely to output some trash, but can just run segfault
 }
 ```

 2. Множественные неупорядоченные side-effects:
 ```c++
 int main() {
    int a = 1;
    std::cout << (a++ + a++);  // can output different values
 }
 ```

 **Объяснение:** `a++` состоит из двух действий. Первое состоит в создании копии текущего значения `a` и возвращение результата, а второе - в изменении состояния `a` (прибавление единички).
 Соответственно, оператор `+` никакой упорядоченности между вычислением значения и побочными эффектами не даёт. Значит, возможны такие ситуации:
  1. В начале всё посчиталось, а лишь только затем произошли изменения `a`. В результате получим в выводе 2
  2. Одно из побочных действий произошло до начала вычисления второго `a++`. Тогда закономерно будет 3

### Нетривиальные примеры

 1. Неожиданные оптимизации ветвлений
  1. Рассмотрим функцию проверки значения в глобальной табличке:
  ```c++
  int table[4] = {};  // contains 0, 0, 0, 0
  
  bool exists_in_table(int v) {
     for (int i = 0; i <= 4; ++i) {  // deliberate error
        if (table[i] == v) {
           return true;
        }
     }
     return false;
  }
  ```
  Если скомпилировать этот код с оптимизациями и попробовать подавать разные значения функции на вход, то обнаружится, что функция всегда возвращает `true`!

  **Объяснение:** компилятор знает, что в программе не должно быть UB. При этом он видит цикл, в котором произойдёт UB, если в выражении `table[i]` будет `i == 4`. Соответственно, вне зависимости
  от любых других факторов, код без UB должен завершить цикл до того, как счётчик достигнет последнего значения. А это, судя по телу цикла, возможно лишь в том случае, когда происходит выполнение
  строчки `return true;`. Так как никаких побочных эффектов у кода нет, он просто целиком заменяется на один statement:
  ```c++
  bool exists_in_table(int) {
     return true;
  }
  ```

  2. В своё время Майк Мирзоянов (спасибо за Codeforces и платформу Polygon) пришёл с таким примером UB:
  ```c++
  for (int i = 0; i < 300; i++)
     std::cout << i << " " << i * 12345678 << std::endl;
  ```
  Если запустить этот код без оптимизаций, то мы узнаем, что переполнение `int` происходит на счётчике со значением 174. А если запустить с оптимизациями, то... программа не завершится

  **Объяснение:** компилятор знает, что в программе не должно быть UB. Раз так, то выражение `i * 12345678` не может приводить к переполнению `int`, а значит `0 <= i <= 173`. Стало быть, условие цикла
  будет всегда верным и его нет смысла проверять.

 2. Вечный цикл без побочных эффектов
  1. Опровержение [Великой теоремы Ферма](https://vk.com/video?z=video-91031095_456241577). Рассмотрим код, проверяющий тройки чисел при `n == 3`:
  ```c++
  int fermat() {
     const int MAX = 1000;
     int a = 1;
     int b = 1;
     int c = 1;
   
     while (1) {
        if (a*a*a == b*b*b + c*c*c) {
           return 1;
        }

        a++;

        if (a > MAX) {
          a = 1;
          ++b;
        }

        if (b > MAX) {
          b = 1;
          ++c;
        }

        if (c > MAX) {
          c = 1;
        }
     }

     return 0;
  }
  ```

  Если запустить этот код без оптимизаций, то он будет просто очень долго (в рамках человеческой жизни бесконечно) работать. Однако, если добавить флаги оптимизаций, то внезапно окажется, что теорема
  опровержена! Правда, тройку мы не знаем, для которой это так...

  **Объяснение:** компилятор знает, что в программе не должно быть UB. Бесконечный цикл без побочных эффектов не имеет смысла, а значит он должен быть конечен. Единственный способ покинуть цикл - это
  исполнить строку `return 1;`, что и сделает компилятор.

  2. Исполнение недостижимого кода. На архитектуре x86-64 и компиляторе clang 15.0.0 можно наблюдать интересную вещь. Рассмотрим незамысловатый код:
  ```c++
  #include <iostream>

  int main() {
     while (true) {}
     return 0;
  }

  void unreachable() {
     std::cout << "Hello, world!" << std::endl;
  }
  ```

  Если запустить этот код с оптимизацией `-O2`, то программа завершится с выводом `Hello, world!` на экран, добивочка.

  **Объяснение:** компилятор знает, что в программе не должно быть UB. В данном случае цикл тривиален, и ничего внутри него компилятор исполнить не может. Однако, по стандарту код должен обладать
  _гарантиями прогресса_. В старом стандарте ситуации, как выше, [не учитывались (см. начало секции intro.progress)](https://open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4713.pdf). В результате компилятор
  мог поменять код так, чтобы этот прогресс сохранился. В современных компиляторах такая ситуация уже невозможна (можно посмотреть просто [свежий стандарт в том же месте](https://eel.is/c++draft/intro.progress))
 
### UB как точка оптимизации

Рассмотрим следующий код:
```c++
#include <iostream>

// execute the code with the command "./a.out 100000000"

int main(int argc, char* argv[]) {  // program arguments
   if (argc < 2) {
      return 1;
   }

   using LoopT = size_t;

   const LoopT n = std::stoi(argv[1]);
   LoopT i = 0;

   for (; i < n; ++i) {
      i += 1;
   }

   std::cout << i << std::endl;
}
```

Если поменять `size_t` на его знакового друга `ssize_t`, то код значительно ускорится (примерно на порядок).

**Объяснение:** дело в том, что UB - это не только про странные ситуации, в которых сложно и непонятно зачем говорить о
поведении программы, но также и _точка оптимизации для компилятора_. Переполнение беззнакового типа - не UB, поэтому компилятор не может никак оптимизировать цикл. А вот со знаковым вариантом всё наоборот, поэтому
код цикла, скорее всего, превращается просто в `i += n`.

## Полезные ссылки

 - https://godbolt.org/ - здесь можно экспериментировать с кодом и смотреть, во что он компилируется
 - https://habr.com/ru/articles/490458/ - познавательная статья про сравнение `cmov` и `jmp`. Вопрос про "удаление ветвления компилятором"
возник тогда, когда затронули момент с branch prediction

